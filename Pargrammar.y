-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Pargrammar where
import Absgrammar
import Lexgrammar
import ErrM

}

%name pProgr Progr
%name pProgrHead ProgrHead
%name pBlock Block
%name pDecPart DecPart
%name pVarDec VarDec
%name pValDec ValDec
%name pFunDec FunDec
%name pFunHead FunHead
%name pType Type
%name pStm Stm
%name pExp1 Exp1
%name pExp2 Exp2
%name pExp3 Exp3
%name pExp4 Exp4
%name pExp Exp
%name pLVal LVal
%name pBoolean Boolean
%name pListStm ListStm
%name pListVarDec ListVarDec
%name pListValDec ListValDec
%name pListFunDec ListFunDec
%name pListType ListType
%name pListExp ListExp

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype { Token }

%token 
 '!=' { PT _ (TS _ 1) }
 '&&' { PT _ (TS _ 2) }
 '(' { PT _ (TS _ 3) }
 ')' { PT _ (TS _ 4) }
 '*' { PT _ (TS _ 5) }
 '+' { PT _ (TS _ 6) }
 ',' { PT _ (TS _ 7) }
 '-' { PT _ (TS _ 8) }
 '->' { PT _ (TS _ 9) }
 '.' { PT _ (TS _ 10) }
 '/' { PT _ (TS _ 11) }
 ':' { PT _ (TS _ 12) }
 ':=' { PT _ (TS _ 13) }
 ';' { PT _ (TS _ 14) }
 '<' { PT _ (TS _ 15) }
 '==' { PT _ (TS _ 16) }
 '>' { PT _ (TS _ 17) }
 'Array' { PT _ (TS _ 18) }
 '[' { PT _ (TS _ 19) }
 ']' { PT _ (TS _ 20) }
 'begin' { PT _ (TS _ 21) }
 'boolean' { PT _ (TS _ 22) }
 'do' { PT _ (TS _ 23) }
 'else' { PT _ (TS _ 24) }
 'end' { PT _ (TS _ 25) }
 'false' { PT _ (TS _ 26) }
 'for' { PT _ (TS _ 27) }
 'function' { PT _ (TS _ 28) }
 'if' { PT _ (TS _ 29) }
 'integer' { PT _ (TS _ 30) }
 'lambda' { PT _ (TS _ 31) }
 'of' { PT _ (TS _ 32) }
 'print' { PT _ (TS _ 33) }
 'program' { PT _ (TS _ 34) }
 'record' { PT _ (TS _ 35) }
 'return' { PT _ (TS _ 36) }
 'skip' { PT _ (TS _ 37) }
 'then' { PT _ (TS _ 38) }
 'to' { PT _ (TS _ 39) }
 'true' { PT _ (TS _ 40) }
 'var' { PT _ (TS _ 41) }
 'while' { PT _ (TS _ 42) }
 '||' { PT _ (TS _ 43) }

L_ident  { PT _ (TV $$) }
L_integ  { PT _ (TI $$) }
L_err    { _ }


%%

Ident   :: { Ident }   : L_ident  { Ident $1 }
Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }

Progr :: { Progr }
Progr : ProgrHead Block '.' { Program $1 $2 } 


ProgrHead :: { ProgrHead }
ProgrHead : 'program' Ident ';' { ProgramHeading $2 } 


Block :: { Block }
Block : DecPart 'begin' ListStm 'end' { PBlock $1 (reverse $3) } 


DecPart :: { DecPart }
DecPart : ListVarDec ListFunDec { DeclPart (reverse $1) (reverse $2) } 


VarDec :: { VarDec }
VarDec : 'var' Ident ':' Type { VarDecl $2 $4 } 


ValDec :: { ValDec }
ValDec : Ident ':' Type { ValDecl $1 $3 } 


FunDec :: { FunDec }
FunDec : FunHead ';' Block { FunDecl $1 $3 } 


FunHead :: { FunHead }
FunHead : 'function' Ident '(' ListVarDec ListValDec ')' ':' Type { FunHeader $2 (reverse $4) (reverse $5) $8 } 


Type :: { Type }
Type : 'integer' { TInt } 
  | 'boolean' { TBool }
  | 'Array' '[' Integer ']' 'of' Type { TArray $3 $6 }
  | 'record' 'begin' ListValDec 'end' { TRecord (reverse $3) }
  | 'lambda' '(' ListType ')' Type { TFunction $3 $5 }


Stm :: { Stm }
Stm : 'begin' ListStm 'end' { StmBlock (reverse $2) } 
  | LVal ':=' Exp { AssignmentStm $1 $3 }
  | 'if' Exp 'then' Stm 'else' Stm { IfStm $2 $4 $6 }
  | 'while' Exp 'do' Stm { WhileStm $2 $4 }
  | 'for' Stm 'to' Exp 'do' Stm { ForStm $2 $4 $6 }
  | 'print' Exp { PrintStm $2 }
  | 'return' Exp { ReturnStm $2 }
  | 'skip' { Skip }


Exp1 :: { Exp }
Exp1 : Exp2 '==' Exp2 { EEqual $1 $3 } 
  | Exp2 '!=' Exp2 { ENotEqual $1 $3 }
  | Exp2 '>' Exp2 { EGreaterThan $1 $3 }
  | Exp2 '<' Exp2 { ELowerThan $1 $3 }
  | Exp2 { $1 }


Exp2 :: { Exp }
Exp2 : Exp2 '&&' Exp3 { EAnd $1 $3 } 
  | Exp2 '||' Exp3 { EOr $1 $3 }
  | Exp2 '+' Exp3 { EAdd $1 $3 }
  | Exp2 '-' Exp3 { ESub $1 $3 }
  | Exp3 { $1 }


Exp3 :: { Exp }
Exp3 : Exp3 '*' Exp4 { EMul $1 $3 } 
  | Exp3 '/' Exp4 { EDiv $1 $3 }
  | Exp4 { $1 }


Exp4 :: { Exp }
Exp4 : Integer { EInt $1 } 
  | LVal { EVar $1 }
  | Boolean { EBool $1 }
  | Ident '(' ListExp ')' { EFuncCall $1 $3 }
  | 'lambda' '(' ListVarDec ListValDec ')' '->' Type ';' Block { ELambda (reverse $3) (reverse $4) $7 $9 }
  | '(' Exp ')' { $2 }


Exp :: { Exp }
Exp : Exp1 { $1 } 


LVal :: { LVal }
LVal : Ident { LValIdent $1 } 
  | Ident '[' Exp ']' { LValArrayField $1 $3 }
  | Ident '.' Ident { LValRecordField $1 $3 }


Boolean :: { Boolean }
Boolean : 'true' { BoolTrue } 
  | 'false' { BoolFalse }


ListStm :: { [Stm] }
ListStm : {- empty -} { [] } 
  | ListStm Stm ';' { flip (:) $1 $2 }


ListVarDec :: { [VarDec] }
ListVarDec : {- empty -} { [] } 
  | ListVarDec VarDec ';' { flip (:) $1 $2 }


ListValDec :: { [ValDec] }
ListValDec : {- empty -} { [] } 
  | ListValDec ValDec ';' { flip (:) $1 $2 }


ListFunDec :: { [FunDec] }
ListFunDec : {- empty -} { [] } 
  | ListFunDec FunDec ';' { flip (:) $1 $2 }


ListType :: { [Type] }
ListType : {- empty -} { [] } 
  | Type { (:[]) $1 }
  | Type ',' ListType { (:) $1 $3 }


ListExp :: { [Exp] }
ListExp : {- empty -} { [] } 
  | Exp { (:[]) $1 }
  | Exp ',' ListExp { (:) $1 $3 }



{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

